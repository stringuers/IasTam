"""
Exploit Chain Agent for DefenSys.

This agent analyzes how multiple vulnerabilities can be chained together
to create more sophisticated attack paths.
"""

import asyncio
import logging
from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass
from enum import Enum

from ..models.vulnerability import Vulnerability, Severity
from ..utils.logger import setup_logger


class AttackStep(Enum):
    """Types of attack steps in an exploit chain."""
    RECONNAISSANCE = "reconnaissance"
    INITIAL_ACCESS = "initial_access"
    PERSISTENCE = "persistence"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DEFENSE_EVASION = "defense_evasion"
    CREDENTIAL_ACCESS = "credential_access"
    DISCOVERY = "discovery"
    LATERAL_MOVEMENT = "lateral_movement"
    COLLECTION = "collection"
    COMMAND_AND_CONTROL = "command_and_control"
    EXFILTRATION = "exfiltration"
    IMPACT = "impact"


@dataclass
class ExploitChain:
    """Represents a chain of vulnerabilities that can be exploited together."""
    chain_id: str
    steps: List[Dict[str, Any]]
    total_risk_score: float
    attack_impact: str
    prerequisites: List[str]
    mitigation_strategies: List[str]
    description: str


class ExploitChainAgent:
    """
    Agent responsible for analyzing attack chains and exploit paths.
    
    This agent identifies how multiple vulnerabilities can be combined
    to create more sophisticated attacks.
    """
    
    def __init__(self, config):
        self.config = config
        self.logger = setup_logger(__name__)
        
        # Vulnerability relationships and dependencies
        self.vulnerability_relationships = {
            "sql_injection": {
                "can_lead_to": ["data_breach", "privilege_escalation", "authentication_bypass"],
                "requires": ["database_access", "user_input"],
                "severity_multiplier": 1.5
            },
            "xss": {
                "can_lead_to": ["session_hijacking", "credential_theft", "malware_distribution"],
                "requires": ["user_interaction", "reflected_input"],
                "severity_multiplier": 1.3
            },
            "authentication_issue": {
                "can_lead_to": ["unauthorized_access", "privilege_escalation", "data_breach"],
                "requires": ["user_credentials"],
                "severity_multiplier": 2.0
            },
            "file_upload_vulnerability": {
                "can_lead_to": ["malware_execution", "server_compromise", "lateral_movement"],
                "requires": ["file_upload_access"],
                "severity_multiplier": 1.8
            }
        }
        
        # Attack chain patterns
        self.attack_patterns = [
            {
                "name": "Web Application Compromise",
                "steps": [
                    AttackStep.RECONNAISSANCE,
                    AttackStep.INITIAL_ACCESS,
                    AttackStep.PERSISTENCE,
                    AttackStep.PRIVILEGE_ESCALATION,
                    AttackStep.DATA_EXFILTRATION
                ],
                "vulnerability_types": ["xss", "sql_injection", "authentication_issue"]
            },
            {
                "name": "File Upload Attack",
                "steps": [
                    AttackStep.RECONNAISSANCE,
                    AttackStep.INITIAL_ACCESS,
                    AttackStep.PERSISTENCE,
                    AttackStep.COMMAND_AND_CONTROL,
                    AttackStep.IMPACT
                ],
                "vulnerability_types": ["file_upload_vulnerability", "authentication_issue"]
            }
        ]
    
    async def analyze_attack_chains(self, vulnerabilities: List[Vulnerability], 
                                  attack_surface: Any) -> List[Dict[str, Any]]:
        """
        Analyze how vulnerabilities can be chained together for attacks.
        
        Args:
            vulnerabilities: List of detected vulnerabilities
            attack_surface: Discovered attack surface
            
        Returns:
            List of exploit chains
        """
        self.logger.info("Starting attack chain analysis")
        
        if not vulnerabilities:
            return []
        
        # Group vulnerabilities by type and location
        vuln_groups = self._group_vulnerabilities(vulnerabilities)
        
        # Find potential attack chains
        attack_chains = []
        
        # Analyze each vulnerability group for chain potential
        for vuln_type, vulns in vuln_groups.items():
            chains = await self._find_chains_for_type(vuln_type, vulns, attack_surface)
            attack_chains.extend(chains)
        
        # Find cross-type attack chains
        cross_chains = await self._find_cross_type_chains(vuln_groups, attack_surface)
        attack_chains.extend(cross_chains)
        
        # Score and rank chains
        scored_chains = self._score_attack_chains(attack_chains)
        
        self.logger.info(f"Attack chain analysis complete. Found {len(scored_chains)} chains")
        return scored_chains
    
    def _group_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> Dict[str, List[Vulnerability]]:
        """Group vulnerabilities by type."""
        groups = {}
        
        for vuln in vulnerabilities:
            vuln_type = vuln.vulnerability_type.value
            if vuln_type not in groups:
                groups[vuln_type] = []
            groups[vuln_type].append(vuln)
        
        return groups
    
    async def _find_chains_for_type(self, vuln_type: str, vulnerabilities: List[Vulnerability], 
                                  attack_surface: Any) -> List[Dict[str, Any]]:
        """Find attack chains for a specific vulnerability type."""
        chains = []
        
        # Check if this vulnerability type can lead to other issues
        if vuln_type in self.vulnerability_relationships:
            relationships = self.vulnerability_relationships[vuln_type]
            
            for vuln in vulnerabilities:
                # Create a basic chain starting with this vulnerability
                chain = {
                    "chain_id": f"{vuln_type}_{vuln.location.file_path}_{vuln.location.line_number}",
                    "vulnerability_type": vuln_type,
                    "steps": [
                        {
                            "step": "initial_vulnerability",
                            "vulnerability": vuln,
                            "description": f"Exploit {vuln.title}",
                            "risk_score": vuln.get_risk_score()
                        }
                    ],
                    "can_lead_to": relationships["can_lead_to"],
                    "prerequisites": relationships["requires"],
                    "severity_multiplier": relationships["severity_multiplier"]
                }
                
                # Add potential follow-up steps
                follow_up_steps = await self._generate_follow_up_steps(vuln, relationships, attack_surface)
                chain["steps"].extend(follow_up_steps)
                
                chains.append(chain)
        
        return chains
    
    async def _find_cross_type_chains(self, vuln_groups: Dict[str, List[Vulnerability]], 
                                    attack_surface: Any) -> List[Dict[str, Any]]:
        """Find attack chains that span multiple vulnerability types."""
        chains = []
        
        # Look for patterns where different vulnerability types can be chained
        for pattern in self.attack_patterns:
            pattern_chains = await self._match_pattern(pattern, vuln_groups, attack_surface)
            chains.extend(pattern_chains)
        
        return chains
    
    async def _match_pattern(self, pattern: Dict[str, Any], vuln_groups: Dict[str, List[Vulnerability]], 
                           attack_surface: Any) -> List[Dict[str, Any]]:
        """Match vulnerabilities to attack patterns."""
        chains = []
        
        pattern_name = pattern["name"]
        required_types = pattern["vulnerability_types"]
        
        # Check if we have vulnerabilities for all required types
        available_types = set(vuln_groups.keys())
        if not all(t in available_types for t in required_types):
            return chains
        
        # Create chains using available vulnerabilities
        for vuln_type in required_types:
            if vuln_type in vuln_groups:
                for vuln in vuln_groups[vuln_type]:
                    chain = {
                        "chain_id": f"{pattern_name}_{vuln_type}_{vuln.location.file_path}",
                        "pattern_name": pattern_name,
                        "vulnerability_type": vuln_type,
                        "steps": [
                            {
                                "step": "pattern_match",
                                "vulnerability": vuln,
                                "description": f"Follow {pattern_name} pattern using {vuln.title}",
                                "risk_score": vuln.get_risk_score()
                            }
                        ],
                        "pattern_steps": pattern["steps"],
                        "severity_multiplier": 1.5  # Cross-type chains are more dangerous
                    }
                    chains.append(chain)
        
        return chains
    
    async def _generate_follow_up_steps(self, vulnerability: Vulnerability, 
                                      relationships: Dict[str, Any], 
                                      attack_surface: Any) -> List[Dict[str, Any]]:
        """Generate potential follow-up attack steps."""
        steps = []
        
        for outcome in relationships["can_lead_to"]:
            step = {
                "step": "potential_escalation",
                "outcome": outcome,
                "description": f"Could lead to {outcome}",
                "risk_score": vulnerability.get_risk_score() * 0.8,  # Slightly lower confidence
                "prerequisites": relationships["requires"]
            }
            steps.append(step)
        
        return steps
    
    def _score_attack_chains(self, chains: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Score and rank attack chains by risk."""
        for chain in chains:
            # Calculate total risk score
            total_risk = sum(step.get("risk_score", 0) for step in chain["steps"])
            
            # Apply severity multiplier
            multiplier = chain.get("severity_multiplier", 1.0)
            total_risk *= multiplier
            
            # Add chain metadata
            chain["total_risk_score"] = total_risk
            chain["attack_impact"] = self._assess_attack_impact(total_risk)
            chain["mitigation_strategies"] = self._generate_mitigation_strategies(chain)
            chain["description"] = self._generate_chain_description(chain)
        
        # Sort by risk score (highest first)
        chains.sort(key=lambda x: x["total_risk_score"], reverse=True)
        
        return chains
    
    def _assess_attack_impact(self, risk_score: float) -> str:
        """Assess the potential impact of an attack chain."""
        if risk_score >= 8.0:
            return "Critical - Complete system compromise likely"
        elif risk_score >= 6.0:
            return "High - Significant data breach or system access"
        elif risk_score >= 4.0:
            return "Medium - Limited data access or service disruption"
        elif risk_score >= 2.0:
            return "Low - Minor security impact"
        else:
            return "Minimal - Limited security risk"
    
    def _generate_mitigation_strategies(self, chain: Dict[str, Any]) -> List[str]:
        """Generate mitigation strategies for an attack chain."""
        strategies = []
        
        vuln_type = chain.get("vulnerability_type", "")
        
        if vuln_type == "sql_injection":
            strategies.extend([
                "Use parameterized queries or prepared statements",
                "Implement input validation and sanitization",
                "Apply principle of least privilege to database access"
            ])
        elif vuln_type == "xss":
            strategies.extend([
                "Implement Content Security Policy (CSP)",
                "Encode all user input before output",
                "Use HTTP-only cookies for session management"
            ])
        elif vuln_type == "authentication_issue":
            strategies.extend([
                "Implement multi-factor authentication",
                "Use strong password policies",
                "Implement account lockout mechanisms"
            ])
        elif vuln_type == "file_upload_vulnerability":
            strategies.extend([
                "Validate file types and content",
                "Scan uploaded files for malware",
                "Store uploaded files outside web root"
            ])
        
        # Add general strategies
        strategies.extend([
            "Implement comprehensive logging and monitoring",
            "Regular security testing and code reviews",
            "Keep all dependencies and frameworks updated"
        ])
        
        return strategies
    
    def _generate_chain_description(self, chain: Dict[str, Any]) -> str:
        """Generate a human-readable description of the attack chain."""
        vuln_type = chain.get("vulnerability_type", "unknown")
        pattern_name = chain.get("pattern_name", "")
        risk_score = chain.get("total_risk_score", 0)
        
        if pattern_name:
            return f"Attack chain following {pattern_name} pattern using {vuln_type} vulnerability (Risk Score: {risk_score:.1f})"
        else:
            return f"Potential attack chain starting with {vuln_type} vulnerability (Risk Score: {risk_score:.1f})"
