"""
Vulnerability Agent for DefenSys.

This agent is responsible for detecting security vulnerabilities in code
using pattern matching, AST analysis, and machine learning models.
"""

import asyncio
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

from ..models.vulnerability import Vulnerability, Severity, VulnerabilityType, CodeLocation, FixSuggestion
from ..analyzers.pattern_matcher import PatternMatcher
from ..analyzers.ast_analyzer import ASTAnalyzer
from ..analyzers.javascript_analyzer import JavaScriptAnalyzer
from ..models.ml_models import VulnerabilityClassifier
from ..utils.logger import setup_logger


@dataclass
class AnalysisContext:
    """Context information for vulnerability analysis."""
    file_path: Path
    content: str
    language: str
    dependencies: List[str]
    framework: Optional[str] = None


class VulnerabilityAgent:
    """
    Agent responsible for detecting security vulnerabilities.
    
    This agent coordinates between different analysis methods to provide
    comprehensive vulnerability detection.
    """
    
    def __init__(self, config):
        self.config = config
        self.logger = setup_logger(__name__)
        
        # Initialize analyzers
        self.pattern_matcher = PatternMatcher(config)
        self.ast_analyzer = ASTAnalyzer(config)
        self.js_analyzer = JavaScriptAnalyzer(config)
        self.ml_classifier = VulnerabilityClassifier()
        
        # Analysis methods to use
        self.use_pattern_matching = True
        self.use_ast_analysis = True
        self.use_ml_analysis = True
        self.use_language_specific = True
    
    async def analyze_vulnerabilities(self, attack_surface, deep_analysis: bool = False) -> List[Vulnerability]:
        """
        Analyze vulnerabilities in the discovered attack surface.
        
        Args:
            attack_surface: AttackSurface object from reconnaissance
            deep_analysis: Whether to perform deep analysis
            
        Returns:
            List of detected vulnerabilities
        """
        self.logger.info("Starting vulnerability analysis")
        
        vulnerabilities = []
        
        # Analyze each file type
        analysis_tasks = []
        
        # Analyze API endpoints
        for endpoint in attack_surface.api_endpoints:
            task = self._analyze_endpoint(endpoint, deep_analysis)
            analysis_tasks.append(task)
        
        # Analyze file uploads
        for upload in attack_surface.file_uploads:
            task = self._analyze_file_upload(upload, deep_analysis)
            analysis_tasks.append(task)
        
        # Analyze authentication points
        for auth_point in attack_surface.authentication_points:
            task = self._analyze_auth_point(auth_point, deep_analysis)
            analysis_tasks.append(task)
        
        # Analyze database connections
        for db_conn in attack_surface.database_connections:
            task = self._analyze_db_connection(db_conn, deep_analysis)
            analysis_tasks.append(task)
        
        # Run all analyses in parallel
        if analysis_tasks:
            results = await asyncio.gather(*analysis_tasks, return_exceptions=True)
            
            for result in results:
                if isinstance(result, Exception):
                    self.logger.error(f"Analysis error: {result}")
                elif isinstance(result, list):
                    vulnerabilities.extend(result)
                elif result:
                    vulnerabilities.append(result)
        
        # Remove duplicates and sort by severity
        vulnerabilities = self._deduplicate_vulnerabilities(vulnerabilities)
        vulnerabilities.sort(key=lambda v: v.get_severity_score(), reverse=True)
        
        self.logger.info(f"Vulnerability analysis complete. Found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities
    
    async def _analyze_endpoint(self, endpoint: Dict[str, Any], deep_analysis: bool) -> List[Vulnerability]:
        """Analyze an API endpoint for vulnerabilities."""
        vulnerabilities = []
        file_path = Path(endpoint['file_path'])
        
        try:
            # Read file content
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Create analysis context
            context = AnalysisContext(
                file_path=file_path,
                content=content,
                language=self._detect_language(file_path),
                dependencies=[]  # TODO: Extract from package files
            )
            
            # Pattern-based analysis
            if self.use_pattern_matching:
                pattern_vulns = await self.pattern_matcher.analyze_endpoint(endpoint, context)
                vulnerabilities.extend(pattern_vulns)
            
            # AST-based analysis
            if self.use_ast_analysis and deep_analysis:
                ast_vulns = await self.ast_analyzer.analyze_file(context)
                vulnerabilities.extend(ast_vulns)
            
            # Language-specific analysis
            if self.use_language_specific and context.language == 'javascript':
                js_vulns = await self.js_analyzer.analyze_endpoint(endpoint, context)
                vulnerabilities.extend(js_vulns)
            
            # ML-based analysis
            if self.use_ml_analysis:
                ml_vulns = await self._ml_analyze_code_snippet(content, file_path, endpoint['line_number'])
                vulnerabilities.extend(ml_vulns)
        
        except Exception as e:
            self.logger.error(f"Error analyzing endpoint {endpoint['file_path']}: {e}")
        
        return vulnerabilities
    
    async def _analyze_file_upload(self, upload: Dict[str, Any], deep_analysis: bool) -> List[Vulnerability]:
        """Analyze file upload functionality for vulnerabilities."""
        vulnerabilities = []
        file_path = Path(upload['file_path'])
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            context = AnalysisContext(
                file_path=file_path,
                content=content,
                language=self._detect_language(file_path),
                dependencies=[]
            )
            
            # Check for common file upload vulnerabilities
            vulns = await self._check_file_upload_vulnerabilities(upload, context)
            vulnerabilities.extend(vulns)
        
        except Exception as e:
            self.logger.error(f"Error analyzing file upload {upload['file_path']}: {e}")
        
        return vulnerabilities
    
    async def _analyze_auth_point(self, auth_point: Dict[str, Any], deep_analysis: bool) -> List[Vulnerability]:
        """Analyze authentication points for vulnerabilities."""
        vulnerabilities = []
        file_path = Path(auth_point['file_path'])
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            context = AnalysisContext(
                file_path=file_path,
                content=content,
                language=self._detect_language(file_path),
                dependencies=[]
            )
            
            # Check for authentication vulnerabilities
            vulns = await self._check_auth_vulnerabilities(auth_point, context)
            vulnerabilities.extend(vulns)
        
        except Exception as e:
            self.logger.error(f"Error analyzing auth point {auth_point['file_path']}: {e}")
        
        return vulnerabilities
    
    async def _analyze_db_connection(self, db_conn: Dict[str, Any], deep_analysis: bool) -> List[Vulnerability]:
        """Analyze database connections for vulnerabilities."""
        vulnerabilities = []
        file_path = Path(db_conn['file_path'])
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            context = AnalysisContext(
                file_path=file_path,
                content=content,
                language=self._detect_language(file_path),
                dependencies=[]
            )
            
            # Check for database vulnerabilities
            vulns = await self._check_db_vulnerabilities(db_conn, context)
            vulnerabilities.extend(vulns)
        
        except Exception as e:
            self.logger.error(f"Error analyzing db connection {db_conn['file_path']}: {e}")
        
        return vulnerabilities
    
    async def _check_file_upload_vulnerabilities(self, upload: Dict[str, Any], context: AnalysisContext) -> List[Vulnerability]:
        """Check for file upload vulnerabilities."""
        vulnerabilities = []
        
        # Check for missing file type validation
        if 'file' in context.content.lower() and 'upload' in context.content.lower():
            if not any(pattern in context.content for pattern in ['mimetype', 'filetype', 'extension']):
                vuln = Vulnerability(
                    vulnerability_type=VulnerabilityType.FILE_UPLOAD,
                    severity=Severity.HIGH,
                    title="Missing File Type Validation",
                    description="File upload functionality lacks proper file type validation",
                    location=CodeLocation(
                        file_path=str(context.file_path),
                        line_number=upload['line_number'],
                        column_number=0
                    ),
                    cwe_id="CWE-434",
                    owasp_category="A01:2021 - Broken Access Control",
                    detection_method="pattern_matching",
                    confidence=0.8,
                    impact_description="Attackers could upload malicious files",
                    fix_suggestions=[
                        FixSuggestion(
                            description="Implement file type validation using MIME type checking",
                            code_example="const allowedTypes = ['image/jpeg', 'image/png']; if (!allowedTypes.includes(file.mimetype)) { throw new Error('Invalid file type'); }",
                            confidence=0.9
                        )
                    ]
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _check_auth_vulnerabilities(self, auth_point: Dict[str, Any], context: AnalysisContext) -> List[Vulnerability]:
        """Check for authentication vulnerabilities."""
        vulnerabilities = []
        
        # Check for hardcoded secrets
        if any(keyword in context.content.lower() for keyword in ['secret', 'password', 'token']):
            if any(pattern in context.content for pattern in ['= "', "= '", '= "', "= '"]):
                vuln = Vulnerability(
                    vulnerability_type=VulnerabilityType.AUTHENTICATION,
                    severity=Severity.CRITICAL,
                    title="Hardcoded Secret",
                    description="Hardcoded secret found in authentication code",
                    location=CodeLocation(
                        file_path=str(context.file_path),
                        line_number=auth_point['line_number'],
                        column_number=0
                    ),
                    cwe_id="CWE-798",
                    owasp_category="A07:2021 - Identification and Authentication Failures",
                    detection_method="pattern_matching",
                    confidence=0.9,
                    impact_description="Hardcoded secrets can be easily discovered by attackers",
                    fix_suggestions=[
                        FixSuggestion(
                            description="Use environment variables for secrets",
                            code_example="const secret = process.env.JWT_SECRET;",
                            confidence=0.9
                        )
                    ]
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _check_db_vulnerabilities(self, db_conn: Dict[str, Any], context: AnalysisContext) -> List[Vulnerability]:
        """Check for database vulnerabilities."""
        vulnerabilities = []
        
        # Check for SQL injection patterns
        if 'query' in context.content.lower() or 'sql' in context.content.lower():
            if any(pattern in context.content for pattern in ['+', '${', '`', 'f"', 'f\'']):
                vuln = Vulnerability(
                    vulnerability_type=VulnerabilityType.SQL_INJECTION,
                    severity=Severity.CRITICAL,
                    title="Potential SQL Injection",
                    description="Database query appears to use string concatenation",
                    location=CodeLocation(
                        file_path=str(context.file_path),
                        line_number=db_conn['line_number'],
                        column_number=0
                    ),
                    cwe_id="CWE-89",
                    owasp_category="A03:2021 - Injection",
                    detection_method="pattern_matching",
                    confidence=0.7,
                    impact_description="SQL injection could lead to data breach",
                    fix_suggestions=[
                        FixSuggestion(
                            description="Use parameterized queries or prepared statements",
                            code_example="db.query('SELECT * FROM users WHERE id = ?', [userId])",
                            confidence=0.9
                        )
                    ]
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _ml_analyze_code_snippet(self, content: str, file_path: Path, line_number: int) -> List[Vulnerability]:
        """Use ML model to analyze code snippet."""
        vulnerabilities = []
        
        try:
            # Split content into lines and get context around the line
            lines = content.split('\n')
            start_line = max(0, line_number - 10)
            end_line = min(len(lines), line_number + 10)
            snippet = '\n'.join(lines[start_line:end_line])
            
            # Use ML classifier
            prediction = self.ml_classifier.predict([snippet])
            
            for pred in prediction['predictions']:
                if pred['is_vulnerable'] and pred['confidence'] > 0.7:
                    vuln = Vulnerability(
                        vulnerability_type=VulnerabilityType.SQL_INJECTION,  # Default, should be determined by model
                        severity=Severity.MEDIUM,
                        title="ML-Detected Vulnerability",
                        description=f"Machine learning model detected potential vulnerability with {pred['confidence']:.2f} confidence",
                        location=CodeLocation(
                            file_path=str(file_path),
                            line_number=line_number,
                            column_number=0
                        ),
                        detection_method="ml_model",
                        confidence=pred['confidence'],
                        impact_description="Potential security vulnerability detected by AI model"
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            self.logger.warning(f"ML analysis failed: {e}")
        
        return vulnerabilities
    
    def _detect_language(self, file_path: Path) -> str:
        """Detect programming language from file extension."""
        extension = file_path.suffix.lower()
        
        language_map = {
            '.js': 'javascript',
            '.ts': 'typescript',
            '.jsx': 'javascript',
            '.tsx': 'typescript',
            '.py': 'python',
            '.java': 'java',
            '.php': 'php',
            '.cs': 'csharp',
            '.go': 'go',
            '.rb': 'ruby'
        }
        
        return language_map.get(extension, 'unknown')
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities."""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            # Create a unique key based on location and type
            key = (vuln.location.file_path, vuln.location.line_number, vuln.vulnerability_type)
            
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
        
        return unique_vulns
